/*=========================================================================

  Program:   Insight Segmentation & Registration Toolkit
  Module:    $RCSfile: itkTestMain.h,v $
  Language:  C++
  Date:      $Date: 2009-03-03 15:09:43 $
  Version:   $Revision:  $

  Copyright (c) Insight Software Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

  Portions of this code are covered under the VTK copyright.
  See VTKCopyright.txt or http://www.kitware.com/VTKCopyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/


#include "itktfDifferenceVisitor.h"
#include "itktfRegressionSupport.h"

#include "itkImage.h"
#include "itkImageFileReader.h"
#include "itkDifferenceImageFilter.h"
#include "itkRescaleIntensityImageFilter.h"
#include "itkExtractImageFilter.h"
#include "itkImageFileWriter.h"

namespace itk {

DifferenceVisitor::DifferenceVisitor(void) 
{        
  this->SetImageInsightToleranceOff();
}

void DifferenceVisitor::SetImageInsightToleranceOff( void ) 
{ 
  this->SetImageInsightTolerance( 0.0, 0, 0 ); 
}

void DifferenceVisitor::SetImageInsightTolerance( double intensityTolerance, 
                                                  unsigned int numberOfPixelTolerance,
                                                  unsigned int radiusTolerance )
{
  m_IntensityTolerance = intensityTolerance;
  m_NumberOfPixelsTolerance = numberOfPixelTolerance;
  m_RadiusTolerance = radiusTolerance;
}

void DifferenceVisitor::Visit(testutil::MeasurementFile &m) 
{
  testutil::MeasurementFile *baseline;
  if ( m.GetAttributeType() == "image/itk" &&
       (baseline = dynamic_cast<testutil::MeasurementFile*>(this->_baseline)) )
    {
    DifferenceTestImage( m, 
                         *baseline, 
                         m_IntensityTolerance,
                         m_NumberOfPixelsTolerance, 
                         m_RadiusTolerance ) ;
    }
  else 
    {
    testutil::DifferenceVisitor::Visit(m);
    }
}

// function was taken from itk's testing main
int DifferenceVisitor::DifferenceTestImage (testutil::MeasurementFile &testMeasurement,
                                  testutil::MeasurementFile &baselineMeasurement,
                                  double intensityTolerance,
                                  unsigned int numberOfPixelsTolerance, 
                                  unsigned int radiusTolerance )
{
  // Use the factory mechanism to read the test and baseline files and convert them to double
  typedef itk::Image<double,ITK_TF_DIMENSION_MAX>        ImageType;
  typedef itk::Image<unsigned char,ITK_TF_DIMENSION_MAX> OutputType;
  typedef itk::Image<unsigned char,2>                      DiffOutputType;
  typedef itk::ImageFileReader<ImageType>                  ReaderType;
  
  fileutil::PathName testImageFilename = testMeasurement.GetFileName();
  fileutil::PathName baselineImageFilename = baselineMeasurement.GetFileName();

  // Read the baseline file
  ReaderType::Pointer baselineReader = ReaderType::New();
  baselineReader->SetFileName(baselineImageFilename.GetPathName());
  
  // Read the file generated by the test
  ReaderType::Pointer testReader = ReaderType::New();
  testReader->SetFileName(testImageFilename.GetPathName());
  
  // The sizes of the baseline and test image must match
  ImageType::SizeType baselineSize;
    baselineSize = baselineReader->GetOutput()->GetLargestPossibleRegion().GetSize();
  ImageType::SizeType testSize;
    testSize = testReader->GetOutput()->GetLargestPossibleRegion().GetSize();
  
  if (baselineSize != testSize)
    {
    std::cerr << "The size of the Baseline image and Test image do not match!" << std::endl;

    std::cerr << "Baseline image: " << baselineImageFilename.GetPathName()
              << " has size " << baselineSize << std::endl;
    std::cerr << "Test image:     " << testImageFilename.GetPathName()
              << " has size " << testSize << std::endl;
    return 1;
    }

  // Now compare the two images
  typedef itk::DifferenceImageFilter<ImageType,ImageType> DiffType;
  DiffType::Pointer diff = DiffType::New();
  diff->SetValidInput(baselineReader->GetOutput());
  diff->SetTestInput(testReader->GetOutput());
  diff->SetDifferenceThreshold( intensityTolerance );
  diff->SetToleranceRadius( radiusTolerance );
  diff->UpdateLargestPossibleRegion();

  unsigned long status = 0;
  status = diff->GetNumberOfPixelsWithDifferences();

  typedef itk::RescaleIntensityImageFilter<ImageType,OutputType> RescaleType;
  typedef itk::ExtractImageFilter<OutputType,DiffOutputType>     ExtractType;
  typedef itk::ImageFileWriter<DiffOutputType>                   WriterType;
  typedef itk::ImageRegion<ITK_TF_DIMENSION_MAX>               RegionType;
  OutputType::SizeType size; 
  size.Fill(0);

  RescaleType::Pointer rescale = RescaleType::New();
  rescale->SetOutputMinimum(itk::NumericTraits<unsigned char>::NonpositiveMin());
  rescale->SetOutputMaximum(itk::NumericTraits<unsigned char>::max());
  rescale->SetInput(diff->GetOutput());
  rescale->UpdateOutputInformation();
  size = rescale->GetOutput()->GetLargestPossibleRegion().GetSize();

  //Get the center slice of the image,  In 3D, the first slice
  //is often a black slice with little debugging information.
  OutputType::IndexType index; index.Fill(0);
  for (unsigned int i = 2; i < ITK_TF_DIMENSION_MAX; i++)
    {
    index[i]=size[i]/2;//NOTE: Integer Divide used to get approximately the center slice
    size[i] = 0;
    }
  
  RegionType region;
  region.SetIndex(index);
  region.SetSize(size);

  ExtractType::Pointer extract = ExtractType::New();
  extract->SetInput(rescale->GetOutput());
  extract->SetExtractionRegion(region);

  WriterType::Pointer writer = WriterType::New();
  writer->SetInput(extract->GetOutput());

  testutil::DoubleNumeric statusMeasurement;
  statusMeasurement.SetValue( static_cast<double>(status) );
  statusMeasurement.SetAttributeName("ImageError "  + testMeasurement.GetAttributeName() );
  std::cout << statusMeasurement << std::endl;

  fileutil::PathName diffName = fileutil::PathName(ITK_REGRESSION_OUTPUT).Append(testImageFilename.Tail().GetPathName()+".diff.png");

    try
      {
      rescale->SetInput(diff->GetOutput());
      rescale->Update();
      }
    catch(const std::exception& e)
      {
      std::cerr << "Error during rescale of " << diffName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during rescale of " << diffName.GetPathName() << std::endl;
      }
    writer->SetFileName( diffName.GetPathName() );
    try
      {
      writer->Update();
      }
    catch(const std::exception& e)
      {
      std::cerr << "Error during write of " << diffName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during write of " << diffName.GetPathName() << std::endl;
      }

    testutil::MeasurementFile outputMeasurement;
    outputMeasurement.SetAttributeType("image/png");

    outputMeasurement.SetAttributeName("Difference " + testMeasurement.GetAttributeName());
    outputMeasurement.SetContent(  diffName.GetPathName() );
    std::cout << outputMeasurement << std::endl;
    
    fileutil::PathName baseName = fileutil::PathName(ITK_REGRESSION_OUTPUT).Append(testImageFilename.Tail().GetPathName()+".base.png");
    try
      {
      rescale->SetInput(baselineReader->GetOutput());
      rescale->Update();
      }
    catch(const std::exception& e)
      {
      std::cerr << "Error during rescale of " << baseName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during rescale of " << baseName.GetPathName() << std::endl;
      }
    try
      {
      writer->SetFileName(baseName.GetPathName());
      writer->Update();
      }
    catch(const std::exception& e)
      {
      std::cerr << "Error during write of " << baseName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during write of " << baseName.GetPathName() << std::endl;
      }
    
    outputMeasurement.SetAttributeName("Baseline " + testMeasurement.GetAttributeName());
    outputMeasurement.SetContent(  baseName.GetPathName() );
    std::cout << outputMeasurement << std::endl;
    
    fileutil::PathName testName = fileutil::PathName(ITK_REGRESSION_OUTPUT).Append(testImageFilename.Tail().GetPathName()+".test.png");
    try
      {
      rescale->SetInput(testReader->GetOutput());
      rescale->Update();
      }
    catch(const std::exception& e)
      {
      std::cerr << "Error during rescale of " << testName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during rescale of " << testName.GetPathName() << std::endl;
      }
    try
      {
      writer->SetFileName(testName.GetPathName());
      writer->Update();
      }
    catch(const std::exception& e) 
      {
      std::cerr << "Error during write of " << testName.GetPathName() << std::endl;
      std::cerr << e.what() << "\n";
      }
    catch (...)
      {
      std::cerr << "Error during write of " << testName.GetPathName() << std::endl;
      }

    
    outputMeasurement.SetAttributeName("Test " + testMeasurement.GetAttributeName());
    outputMeasurement.SetContent( testName.GetPathName() );
    std::cout << outputMeasurement << std::endl;
    
    return (status > numberOfPixelsTolerance) ? 1 : 0;
}


  

}


